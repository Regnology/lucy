package net.regnology.lucy.web.rest.v1;

import java.io.FileNotFoundException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import net.regnology.lucy.config.ApplicationProperties;
import net.regnology.lucy.config.Constants;
import net.regnology.lucy.domain.File;
import net.regnology.lucy.domain.Library;
import net.regnology.lucy.domain.Product;
import net.regnology.lucy.domain.enumeration.*;
import net.regnology.lucy.domain.helper.BasicAuthentication;
import net.regnology.lucy.domain.helper.DifferenceView;
import net.regnology.lucy.domain.helper.Upload;
import net.regnology.lucy.domain.statistics.CountOccurrences;
import net.regnology.lucy.domain.statistics.ProductOverview;
import net.regnology.lucy.domain.statistics.ProductStatistic;
import net.regnology.lucy.repository.ProductCustomRepository;
import net.regnology.lucy.service.ProductCustomService;
import net.regnology.lucy.service.ProductQueryCustomService;
import net.regnology.lucy.service.exceptions.*;
import net.regnology.lucy.web.rest.ProductResource;
import net.regnology.lucy.web.rest.errors.BadRequestAlertException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.annotation.Secured;
import org.springframework.web.bind.annotation.*;
import tech.jhipster.web.util.HeaderUtil;

/**
 * Custom REST controller for managing {@link Product}
 * where changes are inserted that are different from the base class generated by the JHipster generator.<br>
 * API base path: {@code /api/v1}
 */
@RestController
@RequestMapping("/api/v1")
public class ProductCustomResource extends ProductResource {

    private static final Logger log = LoggerFactory.getLogger(ProductCustomResource.class);

    private static final String ENTITY_NAME = "product";

    @Value("${jhipster.clientApp.name}")
    private String applicationName;

    private final ProductCustomService productService;
    private final ApplicationProperties applicationProperties;

    public ProductCustomResource(
        ProductCustomService productService,
        ProductCustomRepository productRepository,
        ProductQueryCustomService productQueryService,
        ApplicationProperties applicationProperties
    ) {
        super(productService, productRepository, productQueryService, productService);
        this.productService = productService;
        this.applicationProperties = applicationProperties;
    }

    /**
     * {@code POST  /products} : Create a new product.
     *
     * @param product the product to create.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new product,
     * or with status {@code 400 (Bad Request)} if the product has already an ID.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PostMapping("/products")
    @Secured({ "ROLE_ADMIN", "ROLE_USER" })
    public ResponseEntity<Product> createProduct(@Valid @RequestBody Product product) throws URISyntaxException {
        return super.createProduct(product);
    }

    /**
     * {@code PUT  /products/:id} : Updates an existing product.
     *
     * @param id      ID of the product to save.
     * @param product the product to update.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the updated product,
     * or with status {@code 400 (Bad Request)} if the product is not valid,
     * or with status {@code 500 (Internal Server Error)} if the product couldn't be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PutMapping("/products/{id}")
    @Secured({ "ROLE_ADMIN", "ROLE_USER" })
    public ResponseEntity<Product> updateProduct(
        @PathVariable(value = "id", required = false) final Long id,
        @Valid @RequestBody Product product
    ) throws URISyntaxException {
        return super.updateProduct(id, product);
    }

    /**
     * {@code PATCH  /products/:id} : Partial updates given fields of an existing product, field will ignore if it is null.
     *
     * @param id      ID of the product to save
     * @param product the product to update
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the updated product,
     * or with status {@code 400 (Bad Request)} if the product is not valid,
     * or with status {@code 404 (Not Found)} if the product is not found,
     * or with status {@code 500 (Internal Server Error)} if the product couldn't be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PatchMapping(value = "/products/{id}", consumes = "application/merge-patch+json")
    @Secured({ "ROLE_ADMIN", "ROLE_USER" })
    public ResponseEntity<Product> partialUpdateProduct(
        @PathVariable(value = "id", required = false) final Long id,
        @NotNull @RequestBody Product product
    ) throws URISyntaxException {
        return super.partialUpdateProduct(id, product);
    }

    /**
     * {@code DELETE  /products/:id} : delete a specific product.
     *
     * @param id ID of the product to delete
     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}.
     */
    @DeleteMapping("/products/{id}")
    @Secured({ "ROLE_ADMIN", "ROLE_USER" })
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        log.debug("REST request to delete Product : {}", id);
        productService.delete(id);

        return ResponseEntity
            .noContent()
            .headers(HeaderUtil.createEntityDeletionAlert(applicationName, false, ENTITY_NAME, id.toString()))
            .build();
    }

    /**
     * {@code GET  /products/:id/oss} : Get an OSS list for a product.
     *
     * @param id     ID of the product
     * @param format file format of the OSS list. {@link ExportFormat}
     * @param type   content type of the OSS list. {@link OssType}
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the OSS list as a {@link File},
     * or with status {@code 400 (Bad Request)} if the product id, format or type are not valid.
     */
    @GetMapping("/products/{id}/oss")
    public ResponseEntity<File> getOssList(
        @PathVariable Long id,
        @RequestParam(value = "format", required = false) String format,
        @RequestParam(value = "type", required = false) String type
    ) {
        log.debug("REST request to download a OSS list of a product");
        ExportFormat exportFormat = ExportFormat.CSV;
        OssType ossType = OssType.DEFAULT;

        // Convert format and type from a string to the specific object
        if (format != null) exportFormat = ExportFormat.getExportFormatByValue(format.toLowerCase());
        if (type != null) ossType = OssType.getOssTypeByValue(type.toLowerCase());

        if (exportFormat == null) throw new BadRequestAlertException("Unsupported OSS list format", ENTITY_NAME, "osserror");
        if (ossType == null) throw new BadRequestAlertException("Unsupported OSS list type", ENTITY_NAME, "osserror");

        Optional<Product> product = productService.findOne(id);

        if (product.isPresent()) {
            try {
                File file = productService.createOssList(product.get(), exportFormat, ossType);
                return ResponseEntity.ok(file);
            } catch (ExportException e) {
                throw new BadRequestAlertException(e.getMessage(), ENTITY_NAME, "idinvalid");
            }
        } else {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idinvalid");
        }
    }

    /**
     * {@code GET  /products/:id/zip} : Download the license text archive for a product.
     *
     * @param id ID of the product
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the license text archive as a {@link File},
     * or with status {@code 400 (Bad Request)} if the product id, format or type are not valid.
     */
    @GetMapping("/products/{id}/zip")
    public ResponseEntity<File> getZip(@PathVariable Long id) {
        log.debug("REST request to download a license text archive for product : {}", id);
        Optional<Product> optionalProduct = productService.findOne(id);

        if (optionalProduct.isPresent()) {
            Product product = optionalProduct.get();
            File zipFile;
            String fileName = product.getName().replace(" ", "_") + "_" + product.getVersion() + ".zip";

            try {
                zipFile = new File(fileName, productService.createLicenseZip(product), Constants.MIME_ZIP);
            } catch (FileNotFoundException e) {
                log.error("Cannot create license ZIP archive for product ID {} : {}", product.getId(), e.getMessage());
                throw new BadRequestAlertException("Cannot create license ZIP archive", ENTITY_NAME, "ziperror");
            }

            HttpHeaders headers = new HttpHeaders();
            headers.add("Content-Disposition", "attachment; filename=\"" + fileName + "\"; filename*=\"" + fileName + "\"");
            return ResponseEntity.ok().headers(headers).body(zipFile);
        } else {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idinvalid");
        }
    }

    /**
     * {@code PUT  /products/:id/transfer} : Transfers OSS lists and license text archive to the target URL in the product.
     *
     * @param id ID of the product
     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)},
     * or with status {@code 400 (Bad Request)} if the product ID is not valid.
     */
    @PutMapping("/products/{id}/transfer")
    @Secured({ "ROLE_ADMIN", "ROLE_USER" })
    public ResponseEntity<Void> transferToTarget(@PathVariable(value = "id", required = false) final Long id) {
        log.debug("REST request to transfer OSS lists and license text archive to target URL of product : {}", id);
        Optional<Product> optionalProduct = productService.findOne(id);

        if (optionalProduct.isPresent()) {
            Product product = optionalProduct.get();

            // TODO transferBundleToTarget should throw an exception if an error occur
            productService.transferBundleToTarget(product);

            return ResponseEntity.noContent().build();
        } else {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idinvalid");
        }
    }

    /**
     * TODO create badges per product
     * {@code GET  /products/:id/badge} : Get a badge with the risk information of a product.
     *
     * @param id ID of the product
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the badge as SVG,
     * or with status {@code 400 (Bad Request)} if the product ID is not valid
     */
    @GetMapping("/products/{id}/badge")
    public ResponseEntity<String> getProductBadge(@PathVariable Long id) {
        log.debug("REST request create a badge for product : {}", id);
        throw new BadRequestAlertException("Not implemented", ENTITY_NAME, "notimplemented");
    }

    /**
     * {@code GET  /products/:id/overview} : Get an overview of a specific product.
     *
     * @param id ID of the product
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the overview,
     * or with status {@code 400 (Bad Request)} if the product is not valid
     */
    @GetMapping("/products/{id}/overview")
    public ResponseEntity<ProductOverview> getProductOverview(@PathVariable Long id) {
        log.debug("REST request to get an overview for product : {}", id);
        Optional<Product> optionalProduct = productService.findOne(id);
        if (optionalProduct.isPresent()) {
            Product product = optionalProduct.get();
            ProductOverview productOverview = productService.getProductOverview(product);

            return ResponseEntity.ok(productOverview);
        } else {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idinvalid");
        }
    }

    /**
     * {@code GET  /products/:id/statistic} : Get statistic information of a specific product.
     *
     * @param id ID of the product
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the statistic,
     * or with status {@code 400 (Bad Request)} if the product is not valid
     */
    @GetMapping("/products/{id}/statistic")
    public ResponseEntity<ProductStatistic> getProductStatistic(@PathVariable Long id) {
        log.debug("REST request to get statistics for product : {}", id);
        Optional<Product> optionalProduct = productService.findOne(id);
        if (optionalProduct.isPresent()) {
            Product product = optionalProduct.get();
            ProductStatistic productStatistic = productService.getProductStatistic(product);

            return ResponseEntity.ok(productStatistic);
        } else {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idinvalid");
        }
    }

    /**
     * {@code GET  /products/:id/risk} : Get the risk information of a product.
     *
     * @param id ID of the product
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the risk,
     * or with status {@code 400 (Bad Request)} if the product is not valid.
     */
    @GetMapping("/products/{id}/risk")
    public ResponseEntity<List<CountOccurrences>> getProductRisk(@PathVariable Long id) {
        log.debug("REST request to get the risk information of product : {}", id);
        Optional<Product> optionalProduct = productService.findOne(id);
        if (optionalProduct.isPresent()) {
            Product product = optionalProduct.get();
            List<CountOccurrences> risks = productService.getProductRisk(product);

            return ResponseEntity.ok(risks);
        } else {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idinvalid");
        }
    }

    /**
     * {@code GET  /products/:id/licenses} : Get the distribution of all licenses of a product.
     *
     * @param id ID of the product
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the licenses,
     * or with status {@code 400 (Bad Request)} if the product is not valid.
     */
    @GetMapping("/products/{id}/licenses")
    public ResponseEntity<List<CountOccurrences>> getProductLicenses(@PathVariable Long id) {
        log.debug("REST request to get the distribution of all licenses of product : {}", id);
        Optional<Product> optionalProduct = productService.findOne(id);
        if (optionalProduct.isPresent()) {
            Product product = optionalProduct.get();

            return ResponseEntity.ok(productService.getProductLicenses(product));
        } else {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idinvalid");
        }
    }

    /**
     * {@code GET  /products/:id/create-archive} : Create a 3rd-party source code archive for a product.
     * Download it or export it to an external plattform.
     *
     * @param id       ID of the product
     * @param format   format of the archive. {@link ArchiveFormat}
     * @param shipment type of shipment method. {@link ShipmentMethod}
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the {@link File} with the archive,
     * or with status {@code 400 (Bad Request)} if the product, format or shipment is not valid
     * or the archive could not be created.
     */
    @GetMapping("/products/{id}/create-archive")
    public ResponseEntity<File> createArchive(
        @PathVariable Long id,
        @RequestParam(value = "format") String format,
        @RequestParam(value = "shipment") String shipment
    ) {
        log.debug("REST request to create an 3rd-party source code archive for product : {}", id);

        ArchiveFormat archiveFormat = ArchiveFormat.FULL;
        ShipmentMethod shipmentMethod = ShipmentMethod.DOWNLOAD;
        if (format != null) archiveFormat = ArchiveFormat.getArchiveFormatByValue(format.toLowerCase());
        if (shipment != null) shipmentMethod = ShipmentMethod.getShipmentMethodByValue(shipment.toLowerCase());

        if (archiveFormat == null) throw new BadRequestAlertException("Unsupported archive format", ENTITY_NAME, "archiveerror");
        if (shipmentMethod == null) throw new BadRequestAlertException("Unsupported shipment method", ENTITY_NAME, "archiveerror");
        Optional<Product> optionalProduct = productService.findOne(id);
        if (optionalProduct.isEmpty()) {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idinvalid");
        }

        var product = optionalProduct.get();
        Map<File, Boolean> resultMap;
        File archiveFile;
        boolean complete;
        var headers = new HttpHeaders();
        try {
            resultMap = productService.createArchive(product, archiveFormat, shipmentMethod);
            if (resultMap.keySet().stream().findFirst().isPresent()) {
                archiveFile = resultMap.keySet().stream().findFirst().get();
                complete = resultMap.get(archiveFile);
            } else {
                throw new BadRequestAlertException("Could not create the archive.", ENTITY_NAME, "archiveerror");
            }
        } catch (StorageException | RemoteRepositoryException | ZIPException | UploadException | FileNotFoundException e) {
            throw new BadRequestAlertException(e.getMessage(), ENTITY_NAME, "archiveerror");
        }

        if (!complete) {
            headers.add("COMPLETE", "Archive is not complete. Please check archive log.");
        }

        if (shipmentMethod.equals(ShipmentMethod.EXPORT)) {
            headers.add(
                "PLATFORM",
                "Successfully exported archive " +
                archiveFile.getFileName() +
                " to " +
                applicationProperties.getSourceCodeArchive().getUploadPlatform()
            );
            return ResponseEntity.noContent().headers(headers).build();
        } else {
            headers.add(
                "Content-Disposition",
                "attachment; filename=\"" + archiveFile.getFileName() + "\"; filename*=\"" + archiveFile.getFileName() + "\""
            );
            return ResponseEntity.ok().headers(headers).body(archiveFile);
        }
    }

    /**
     * {@code POST  /products/:id/create-next-version} : Create a product with a new version based on another product.
     *
     * @param id ID of the base product.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new product,
     * or with status {@code 400 (Bad Request)} if the base product in invalid.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PostMapping("/products/{id}/create-next-version")
    @Secured({ "ROLE_ADMIN", "ROLE_USER" })
    public ResponseEntity<Product> createNextProduct(
        @PathVariable final Long id,
        @RequestParam(value = "version") String version,
        @RequestParam(value = "delivered", required = false, defaultValue = "true") Boolean delivered,
        @RequestParam(value = "copy", required = false, defaultValue = "false") Boolean copying
    ) throws URISyntaxException {
        log.debug("REST request to create next product version from product : {}", id);
        if (id == null) {
            throw new BadRequestAlertException("Invalid id", ENTITY_NAME, "idnull");
        }

        // TODO add exception if product id does not exist (Bug)
        Product result = productService.createNextVersion(id, version, delivered, copying);

        return ResponseEntity
            .created(new URI("/api/products/" + result.getId()))
            .headers(HeaderUtil.createEntityCreationAlert(applicationName, false, ENTITY_NAME, result.getId().toString()))
            .body(result);
    }

    /**
     * {@code POST  /products/:id/add-libraries} : Add manually libraries to a product.
     *
     * @param id        ID of the product
     * @param libraries list of libraries to be added
     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)},
     * or with status {@code 400 (Bad Request)} if the product does not exist.
     */
    @PostMapping("/products/{id}/add-libraries")
    @Secured({ "ROLE_ADMIN", "ROLE_USER" })
    public ResponseEntity<Void> addLibraries(@PathVariable Long id, @RequestBody List<Library> libraries) {
        log.debug("REST request to add libraries to product : {}", id);
        Optional<Product> optionalProduct = productService.findOne(id);

        if (optionalProduct.isPresent()) {
            Product product = optionalProduct.get();
            productService.addLibraries(product, libraries);

            return ResponseEntity
                .noContent()
                .headers(HeaderUtil.createAlert(applicationName, "Libraries have been added successfully", ENTITY_NAME))
                .build();
        } else {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idnotfound");
        }
    }

    /**
     * {@code POST  /products/:id/upload} : Upload of a BOM or archive to a product.
     *
     * @param id     ID of the product
     * @param delete true if the libraries from a previous upload should be deleted, or
     *               false if the libraries from the new upload should be added to the previous results
     * @param upload The Upload object with libraries
     * @return The {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}, if the processing is successfully started,
     * or with status {@code 400 (Bad Request)} if an error occurred during processing or the product does not exist.
     */
    @PostMapping("/products/{id}/upload")
    @Secured({ "ROLE_ADMIN", "ROLE_USER" })
    public ResponseEntity<Void> upload(
        @PathVariable Long id,
        @RequestParam(value = "delete", defaultValue = "true") boolean delete,
        @RequestBody Upload upload
    ) {
        log.debug("REST request with upload to product : {}", id);
        if (!productService.existsById(id)) {
            throw new BadRequestAlertException("Product not found", ENTITY_NAME, "idnotfound");
        }

        Product product;
        Optional<Product> optionalProduct = productService.findOne(id);

        if (optionalProduct.isPresent()) {
            product = optionalProduct.get();

            product.setUploadState(UploadState.PROCESSING);
            productService.saveAndFlush(product);
        } else {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idnotfound");
        }

        try {
            productService.processUpload(product, upload, delete);
        } catch (UploadException e) {
            log.error("Error while processing the upload : {}", e.getMessage());
        }

        return ResponseEntity.noContent().headers(HeaderUtil.createAlert(applicationName, "Upload was successful", ENTITY_NAME)).build();
    }

    /**
     * {@code GET  /products/:id/in-development-product} : Get the product that is "In Development".
     *
     * @param id ID of the product
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the product,
     * or with status {@code 400 (Bad Request)} if the product is not valid or
     * no unique product which is "In Development" could be found.
     */
    @GetMapping("/products/{id}/in-development-product")
    public ResponseEntity<Product> getInDevelopmentProductById(@PathVariable Long id) {
        Optional<Product> optionalProduct = productService.findOne(id);

        if (optionalProduct.isPresent()) {
            Product product = optionalProduct.get();

            try {
                return ResponseEntity.ok().body(productService.getInDevelopmentProduct(product));
            } catch (ProductException e) {
                throw new BadRequestAlertException(e.getMessage(), ENTITY_NAME, "noproduct");
            }
        } else {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idnotfound");
        }
    }

    /**
     * {@code GET  /products/compare} : Compare two product for differences.
     *
     * @param firstProductId  First product ID
     * @param secondProductId Second product ID
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the differences of the compared products,
     * or with status {@code 400 (Bad Request)} if the product IDs are not valid.
     */
    @GetMapping("/products/compare")
    public ResponseEntity<DifferenceView> compare(
        @RequestParam(value = "firstProductId") Long firstProductId,
        @RequestParam(value = "secondProductId") Long secondProductId
    ) {
        Optional<Product> optionalFirstProduct = productService.findOne(firstProductId);
        Optional<Product> optionalSecondProduct = productService.findOne(secondProductId);

        if (optionalFirstProduct.isPresent() && optionalSecondProduct.isPresent()) {
            Product firstProduct = optionalFirstProduct.get();
            Product secondProduct = optionalSecondProduct.get();

            return ResponseEntity.ok().body(productService.compare(firstProduct, secondProduct));
        } else {
            throw new BadRequestAlertException("Cannot find Product", ENTITY_NAME, "idnotfound");
        }
    }

    /**
     * {@code GET  /products/:id/upload-by-url} : Upload a BOM or archive from a URL.
     * It's possible to specify credentials for a basic authentication.
     *
     * @param id          ID of the product for the upload
     * @param url         URL of the file
     * @param delete      true if the libraries from a previous upload should be deleted, or
     *                    false if the libraries from the new upload should be added to the previous results
     * @param credentials The basic authentication credentials
     * @return The {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}, if the processing is successfully started,
     * or with status {@code 400 (Bad Request)} if an error occurred during processing or the product does not exist.
     */
    @PostMapping("/products/{id}/upload-by-url")
    @Secured({ "ROLE_ADMIN", "ROLE_USER" })
    public ResponseEntity<Void> uploadByUrl(
        @PathVariable Long id,
        @RequestParam(value = "url") String url,
        @RequestParam(value = "delete", defaultValue = "true") boolean delete,
        @RequestBody BasicAuthentication credentials
    ) {
        log.debug("REST request with upload to product by URL : {}", id);

        if (!productService.existsById(id)) {
            throw new BadRequestAlertException("Product not found", ENTITY_NAME, "idnotfound");
        }

        Product product;
        Optional<Product> optionalProduct = productService.findOne(id);

        if (optionalProduct.isPresent()) {
            product = optionalProduct.get();

            product.setUploadState(UploadState.PROCESSING);
            productService.saveAndFlush(product);
        } else {
            throw new BadRequestAlertException("Cannot find Product ID", ENTITY_NAME, "idnotfound");
        }

        try {
            String contentType = productService.preCheckForUploadByUrl(product, url, credentials);
            productService.processUploadByUrl(product, url, credentials, delete, contentType);
        } catch (UploadException e) {
            log.error("Error while downloading file : {}", e.getMessage());
            product.setUploadState(UploadState.FAILURE);
            productService.saveAndFlush(product);
            throw new BadRequestAlertException(e.getMessage(), ENTITY_NAME, "uploaderror");
        }

        return ResponseEntity
            .noContent()
            .headers(HeaderUtil.createAlert(applicationName, "Downloading and processing file", ENTITY_NAME))
            .build();
    }
}
