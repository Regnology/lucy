package net.regnology.lucy.web.rest.v1;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Optional;
import javax.validation.Valid;
import net.regnology.lucy.domain.Product;
import net.regnology.lucy.domain.Upload;
import net.regnology.lucy.domain.enumeration.EntityUploadChoice;
import net.regnology.lucy.domain.enumeration.UploadState;
import net.regnology.lucy.repository.UploadCustomRepository;
import net.regnology.lucy.service.ProductCustomService;
import net.regnology.lucy.service.UploadCustomService;
import net.regnology.lucy.service.exceptions.UploadException;
import net.regnology.lucy.web.rest.UploadResource;
import net.regnology.lucy.web.rest.errors.BadRequestAlertException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.jhipster.web.util.HeaderUtil;

/**
 * Custom REST controller for managing {@link Upload}
 * where changes are inserted that are different from the base class generated by the JHipster generator.<br>
 * API base path: {@code /api/v1}
 */
@RestController
@RequestMapping("/api/v1")
public class UploadCustomResource extends UploadResource {

    private static final Logger log = LoggerFactory.getLogger(UploadCustomResource.class);

    private static final String ENTITY_NAME = "upload";

    @Value("${jhipster.clientApp.name}")
    private String applicationName;

    private final UploadCustomService uploadService;
    private final ProductCustomService productService;

    public UploadCustomResource(
        UploadCustomService uploadService,
        UploadCustomRepository uploadRepository,
        ProductCustomService productService
    ) {
        super(uploadService, uploadRepository);
        this.uploadService = uploadService;
        this.productService = productService;
    }

    /**
     * {@code POST  /uploads} : Create a new upload.
     *
     * @param upload the upload to create.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new upload, or with status {@code 400 (Bad Request)} if the upload has already an ID.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PostMapping("/uploads")
    public ResponseEntity<Upload> createUpload(@Valid @RequestBody Upload upload) throws URISyntaxException {
        log.debug("REST request to save Upload : {}", upload);
        if (upload.getId() != null) {
            throw new BadRequestAlertException("A new upload cannot already have an ID", ENTITY_NAME, "idexists");
        }

        try {
            if (upload.getEntityToUpload() == EntityUploadChoice.PRODUCT) {
                Optional<Product> optionalProduct = productService.findOne(Long.valueOf(upload.getRecord()));

                if (optionalProduct.isPresent()) {
                    Product product = optionalProduct.get();
                    product.setUploadState(UploadState.PROCESSING);
                    productService.save(product);
                }
            }
            uploadService.uploadHandler(upload);
        } catch (UploadException e) {
            if (upload.getEntityToUpload() == EntityUploadChoice.PRODUCT) {
                Optional<Product> optionalProduct = productService.findOne(Long.valueOf(upload.getRecord()));

                if (optionalProduct.isPresent()) {
                    Product product = optionalProduct.get();
                    product.setUploadState(UploadState.FAILURE);
                    productService.save(product);
                }
            }
            throw new BadRequestAlertException(e.getMessage(), ENTITY_NAME, "uploaderror");
        }

        Upload result = uploadService.save(upload);
        return ResponseEntity
            .created(new URI("/api/uploads/" + result.getId()))
            .headers(HeaderUtil.createEntityCreationAlert(applicationName, false, ENTITY_NAME, result.getId().toString()))
            .body(result);
    }
}
